/* This script handles communication with decrypted message iframes */

'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var FrameComm = (function () {
	/** Constructor for creating a new FrameComm
  * @param cryptoManager A CryptoManager object
 */

	function FrameComm(cryptoManager) {
		_classCallCheck(this, FrameComm);

		this.cryptoManager = cryptoManager;
		this.frameOrigin = 'https://decrypt.grd.me';
		this.FRAME_SECRET = this.cryptoManager.getRandomString(64);
		window.addEventListener('message', this.receiveMessage.bind(this), false);
	}

	/** Receive a message from the decrypted frames
  * @param event An event generated by message passing
 */

	_createClass(FrameComm, [{
		key: 'receiveMessage',
		value: function receiveMessage(event) {
			var _this = this;

			try {
				var _ret = (function () {
					if (event.data.from !== _this.frameOrigin) {
						return {
							v: undefined
						};
					}
					var data = event.data.encrypted;
					data = CryptoJS.AES.decrypt(data, _this.FRAME_SECRET);
					data = data.toString(CryptoJS.enc.Utf8);
					if (!data) {
						return {
							v: undefined
						};
					}
					data = JSON.parse(data);
					if (data.id === 'event') {
						if (data.event.type === 'click') {
							document.querySelector(data.event.selector).click();
						} else if (data.event.type === 'submit') {
							document.querySelector(data.event.selector).submit();
						} else {
							$(data.event.selector).trigger(data.event.type);
						}
					} else if (data.id === 'ready') {
						$('[grdMeUID="' + data.uid + '"]').children(':not(iframe[grdMeFrameUID="' + data.uid + '"])').hide();
						$('iframe[grdMeFrameUID="' + data.uid + '"]').show();
						_this.msg(data.uid, { id: 'decryptIndicator', decryptIndicator: _this.cryptoManager.preferences.decryptIndicator });
						_this.msg(data.uid, { id: 'emojis', emojis: _this.cryptoManager.preferences.emojis });
					} else if (data.id === 'adjustHeight') {
						$('iframe[grdMeFrameUID="' + data.uid + '"]').height(data.height);
					} else if (data.id === 'click') {
						if (data.target === '_blank') {
							port.postMessage({
								id: 'newTab',
								href: data.href
							});
						} else {
							window.location.assign(data.href);
						}
					} else if (data.id === 'decrypt') {
						(function () {
							var ciphertext = data.ciphertext;
							var finish = function finish(originalPlaintext) {
								var plaintext = originalPlaintext;
								if (!plaintext) {
									plaintext = _this.cryptoManager.UNABLE_TO_DECRYPT + ' ' + _this.cryptoManager.UNABLE_START_TAG + data.ciphertext + _this.cryptoManager.UNABLE_END_TAG;
								}
								_this.msg(data.uid, {
									id: 'decryptCallback',
									plaintext: plaintext,
									returnId: data.returnId
								});
							};
							if (ciphertext.charAt(0) === _this.cryptoManager.NONCE_CHAR) {
								(function () {
									var hash = ciphertext.slice(1);
									$.ajax({
										url: 'https://grd.me/message/get',
										type: 'GET',
										data: {
											hash: hash
										},
										success: function success(data) {
											if (data && data.status && data.status[0] && !data.status[0].code) {
												for (var i = 0; i < data.messages.length; i++) {
													if (new CryptoJS.SHA256(data.messages[i].message + data.messages[i].rand).toString().slice(0, 60) === hash) {
														finish(_this.cryptoManager.decryptText(ciphertext));
														return;
													}
												}
												finish(false);
											} else {
												finish(false);
											}
										},
										error: function error() {
											finish(false);
										}
									});
								})();
							} else {
								finish(_this.cryptoManager.decryptText(ciphertext));
							}
						})();
					}
				})();

				if (typeof _ret === 'object') return _ret.v;
			} catch (e) {
				console.log('INFO unable to receive and decrypt message - this usually happens when the message comes from someone other than grd me.', e);
			}
		}

		/** Send a message to a decrypted frame
   * uid: the uid of the frame
   * data: the data to send
  */
	}, {
		key: 'msg',
		value: function msg(uid, data) {
			if ($('iframe[grdMeFrameUID="' + uid + '"]').get(0) && !$('iframe[grdMeFrameUID="' + uid + '"]').attr('src').indexOf(this.frameOrigin) && $('iframe[grdMeFrameUID="' + uid + '"]').get(0).contentWindow) {
				var encryptedText = CryptoJS.AES.encrypt(JSON.stringify(data), this.FRAME_SECRET);
				encryptedText = encryptedText.toString();
				$('iframe[grdMeFrameUID="' + uid + '"]').get(0).contentWindow.postMessage({
					encrypted: encryptedText,
					to: this.frameOrigin
				}, '*');
			}
		}
	}]);

	return FrameComm;
})();

if (typeof module !== 'undefined' && module.exports) {
	module.exports = FrameComm;
} else {
	window.FrameComm = FrameComm;
}