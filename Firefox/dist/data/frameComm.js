/* This script handles communication with decrypted message iframes */

'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var FrameComm = (function () {
	/** Constructor for creating a new FrameComm
  * @param port The port to communicate with the background script
  * @param cryptoManager A CryptoManager object
  * @param callbackWrap A function to wrap around background script callbacks
 */

	function FrameComm(port, cryptoManager, callbackWrap) {
		_classCallCheck(this, FrameComm);

		this.port = port;
		this.cryptoManager = cryptoManager;
		this.callbackWrap = callbackWrap;
		this.frameOrigin = 'https://decrypt.grd.me';
		this.FRAME_SECRET = cryptoManager.getRandomString(64);
		window.addEventListener('message', this.receiveMessage.bind(this), false);
	}

	/** Receive a message from the decrypted frames
  * @param event An event generated by message passing
 */

	_createClass(FrameComm, [{
		key: 'receiveMessage',
		value: function receiveMessage(event) {
			var _this = this;

			try {
				var _ret = (function () {
					if (event.data.from !== _this.frameOrigin) {
						return {
							v: undefined
						};
					}
					var data = event.data.encrypted;
					data = CryptoJS.AES.decrypt(data, _this.FRAME_SECRET);
					data = data.toString(CryptoJS.enc.Utf8);
					if (!data) {
						return {
							v: undefined
						};
					}
					data = JSON.parse(data);
					if (data.id === 'event') {
						if (data.event.type === 'click') {
							document.querySelector(data.event.selector).click();
						} else if (data.event.type === 'submit') {
							document.querySelector(data.event.selector).submit();
						} else {
							$(data.event.selector).trigger(data.event.type);
						}
					} else if (data.id === 'ready') {
						$('[grdMeUID="' + data.uid + '"]').children(':not(iframe[grdMeFrameUID="' + data.uid + '"])').hide();
						$('iframe[grdMeFrameUID="' + data.uid + '"]').show();
						_this.msg(data.uid, { id: 'decryptIndicator', decryptIndicator: _this.cryptoManager.preferences.decryptIndicator });
						_this.msg(data.uid, { id: 'emojis', emojis: _this.cryptoManager.preferences.emojis });
					} else if (data.id === 'adjustHeight') {
						$('iframe[grdMeFrameUID="' + data.uid + '"]').height(data.height);
					} else if (data.id === 'click') {
						if (data.target === '_blank') {
							_this.port.emit('newTab', data.href);
						} else {
							window.location.assign(data.href);
						}
					} else if (data.id === 'decrypt') {
						var ciphertext = data.ciphertext;
						var callback = _this.callbackWrap(function (originalPlaintext) {
							var plaintext = originalPlaintext;
							if (!plaintext) {
								plaintext = _this.cryptoManager.UNABLE_TO_DECRYPT + ' ' + _this.cryptoManager.UNABLE_START_TAG + data.ciphertext + _this.cryptoManager.UNABLE_END_TAG;
							}
							_this.msg(data.uid, { id: 'decryptCallback', plaintext: plaintext, returnId: data.returnId });
						});
						if (ciphertext.charAt(0) === _this.cryptoManager.NONCE_CHAR) {
							var hash = ciphertext.slice(1);
							_this.port.emit('message_get', {
								hash: hash,
								callback: callback
							});
						} else {
							_this.port.emit('decrypt', {
								ciphertext: ciphertext,
								callback: callback
							});
						}
					}
				})();

				if (typeof _ret === 'object') return _ret.v;
			} catch (e) {
				console.log('INFO unable to receive and decrypt message - this usually happens when the message comes from someone other than grd me.', e);
			}
		}

		/** Send a message to a decrypted frame
   * @param uid The uid of the frame
   * @param data The data to send
  */
	}, {
		key: 'msg',
		value: function msg(uid, data) {
			var $frame = $('iframe[grdMeFrameUID="' + uid + '"]');
			if ($frame.get(0) && !$frame.attr('src').indexOf(this.frameOrigin) && $frame.get(0).contentWindow) {
				var encryptedData = CryptoJS.AES.encrypt(JSON.stringify(data), this.FRAME_SECRET).toString();
				$frame.get(0).contentWindow.postMessage({
					encrypted: encryptedData,
					to: this.frameOrigin
				}, '*');
			}
		}
	}]);

	return FrameComm;
})();

if (typeof module !== 'undefined' && module.exports) {
	module.exports = FrameComm;
} else {
	window.FrameComm = FrameComm;
}